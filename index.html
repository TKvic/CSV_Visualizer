<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV Data Multi-Graph Visualizer</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter for clean typography -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the app */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased; /* Smoother fonts */
            -moz-osx-font-smoothing: grayscale;
        }
        canvas {
            /* Ensures canvas scales correctly within its container while maintaining aspect ratio */
            display: block;
            width: 100%; /* Take full width of parent */
            max-width: 800px; /* Limits the max width of the canvas */
            height: auto; /* Maintains aspect ratio */
            margin: 0 auto; /* Center the canvas within its container */
        }
        /* Specific styling for the global X-axis container */
        #global-x-axis-ruler {
            position: relative; /* For absolute positioning of cursor labels */
            height: 60px; /* Space for X-axis labels */
            background-color: black;
            border-top: 1px solid #4b5563; /* Axis color */
            padding: 10px 0; /* No horizontal padding here, spans the width */
            display: flex;
            justify-content: space-between; /* Spacing for tick values */
            align-items: flex-start;
            font-size: 14px;
            color: #e5e7eb;
            width: 100%; /* Spans the full width of the graphs container */
            max-width: 800px; /* Aligns with graph width */
            box-sizing: border-box; /* Include padding in width */
            padding-left: var(--padding-left-computed); /* Dynamic padding */
            padding-right: var(--padding-right-computed); /* Dynamic padding */
        }
        /* Style for the shared global vertical cursor */
        #vertical-cursor-global {
            position: absolute;
            background-color: #ff0000; /* Red cursor line */
            width: 1px;
            pointer-events: none;
            z-index: 50; /* Ensure it's above graphs */
            display: none; /* Hidden by default */
            /* Top and height will be set dynamically */
        }
        /* Style for the global X-label that moves with the cursor */
        #global-x-label {
            position: absolute;
            background-color: #1a1a1a; /* Dark background for label */
            color: #ff0000; /* Red text for label */
            font-size: 12px;
            padding: 2px 5px;
            border-radius: 3px;
            pointer-events: none;
            transform: translateX(-50%); /* Center horizontally */
            z-index: 50;
            display: none; /* Hidden by default */
            /* Top and left will be set dynamically */
            bottom: 5px; /* Position relative to its parent container */
        }

    </style>
</head>
<body class="min-h-screen bg-black p-4 flex flex-col items-center text-gray-100">

    <h1 class="text-4xl font-bold text-red-500 mb-6 rounded-lg p-2 shadow-lg">
        CSV Data Multi-Graph Visualizer
    </h1>

    <!-- File input section -->
    <div class="bg-gray-950 p-6 rounded-2xl shadow-lg mb-8 w-full max-w-2xl flex flex-col items-center border border-gray-800">
        <label for="csv-upload" class="block text-lg font-medium text-gray-100 mb-4">
            Upload a CSV File to view its graphs:
        </label>
        <input
            type="file"
            id="csv-upload"
            accept=".csv"
            class="block w-full text-sm text-gray-300
                    file:mr-4 file:py-2 file:px-4
                    file:rounded-full file:border-0
                    file:text-sm file:font-semibold
                    file:bg-red-900 file:text-red-200
                    hover:file:bg-red-800 hover:file:text-white cursor-pointer
                    rounded-lg shadow-sm"
        />
        <p id="error-message" class="mt-4 text-red-300 text-sm font-medium p-2 bg-red-900 rounded-lg w-full text-center hidden">
            <!-- Error messages will be displayed here -->
        </p>
    </div>

    <!-- Graphs display section -->
    <div id="graphs-container" class="flex flex-col items-center gap-0 w-full max-w-5xl relative">
        <div id="initial-message" class="bg-gray-950 p-6 rounded-2xl shadow-lg w-full max-w-2xl text-center text-gray-300 border border-gray-800">
            <p>Upload a CSV file above to see the graphs!</p>
            <p class="text-sm mt-2">
                The first column will be used for the X-axis (time/index), and each subsequent numeric column will be displayed as a separate graph.
            </p>
        </div>
        <!-- Global vertical cursor line - positioned here to span all graphs -->
        <div id="vertical-cursor-global"></div>
        <div id="global-x-label"></div>
        <!-- Graphs will be dynamically added here -->
    </div>

    <script>
        // --- Global Variables and Constants ---
        const PADDING = 25; // Reduced padding for tighter graphs
        const INTRINSIC_CANVAS_WIDTH = 800; // Designed drawing width of the canvas in pixels
        const INTRINSIC_CANVAS_HEIGHT = 200; // Adjusted height for more compact, stacked graphs
        const FONT_COLOR = '#e5e7eb'; // Light gray for text
        const AXIS_COLOR = '#4b5563'; // Darker gray for axis lines
        const GRID_COLOR = 'rgba(255, 0, 0, 0.2)'; // Faint red for grid lines
        const DATA_LINE_COLOR = '#ff0000'; // Pure red for data lines
        const CURSOR_COLOR = '#ff0000'; // Pure red for cursor lines and labels

        // Elements from the DOM
        const csvUploadInput = document.getElementById('csv-upload');
        const graphsContainer = document.getElementById('graphs-container');
        const errorMessageElement = document.getElementById('error-message');
        const initialMessageElement = document.getElementById('initial-message');
        const globalVerticalCursor = document.getElementById('vertical-cursor-global');
        const globalXLabel = document.getElementById('global-x-label');

        let allSeriesData = []; // To store all processed series data globally
        let globalMinX = 0; // Overall min X across all series
        let globalMaxX = 0; // Overall max X across all series
        let globalXAxisLabel = ''; // To store the X-axis label from the first column

        // --- Helper Functions ---

        /**
         * @brief Displays an error message to the user.
         * @param message The error message to display.
         */
        function displayError(message) {
            errorMessageElement.textContent = message;
            errorMessageElement.classList.remove('hidden');
        }

        /**
         * @brief Hides the error message.
         */
        function hideError() {
            errorMessageElement.classList.add('hidden');
            errorMessageElement.textContent = '';
        }

        /**
         * @brief Parses a CSV string into a 2D array of strings.
         * Handles quoted fields and various line endings.
         * @param text The CSV content as a string.
         * @return A 2D array representing the parsed CSV data.
         */
        function parseCSV(text) {
            const rows = [];
            let inQuote = false;
            let currentRow = [];
            let currentField = '';

            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const nextChar = text[i + 1];

                if (char === '"') {
                    if (inQuote && nextChar === '"') { // Handle escaped double quote "" -> "
                        currentField += '"';
                        i++; // Skip the next quote
                    } else {
                        inQuote = !inQuote;
                    }
                } else if (char === ',' && !inQuote) { // Field delimiter
                    currentRow.push(currentField);
                    currentField = '';
                } else if (char === '\n' && !inQuote) { // Row delimiter (newline)
                    currentRow.push(currentField);
                    rows.push(currentRow);
                    currentRow = [];
                    currentField = '';
                    if (text[i + 1] === '\r') i++; // Handle Windows \r\n
                } else if (char === '\r' && !inQuote) { // Handle Mac \r (old style)
                    currentRow.push(currentField);
                    rows.push(currentRow);
                    currentRow = [];
                    currentField = '';
                } else {
                    currentField += char;
                }
            }
            // Add the last field and row if any content remains
            if (currentField !== '' || currentRow.length > 0) {
                currentRow.push(currentField);
                rows.push(currentRow);
            }

            // Filter out any completely empty rows that might result from trailing newlines
            return rows.filter(row => row.some(field => field.trim() !== ''));
        }

        /**
         * @brief Finds the index of the data point closest to the given data X-value.
         * @param xValues Array of X-axis data points.
         * @param targetX The target X-value to find the closest point for.
         * @return The index of the closest data point, or -1 if xValues is empty.
         */
        function findClosestDataPointIndex(xValues, targetX) {
            if (xValues.length === 0) return -1;

            let closestIndex = 0;
            let minDiff = Math.abs(xValues[0] - targetX);

            for (let i = 1; i < xValues.length; i++) {
                const diff = Math.abs(xValues[i] - targetX);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestIndex = i;
                }
            }
            return closestIndex;
        }

        /**
         * @brief Draws a single line graph on a given canvas.
         * @param canvas The HTMLCanvasElement to draw on.
         * @param seriesName The name of the data series (title for the Y-axis).
         * @param xValues Array of numeric X-axis values.
         * @param yValues Array of numeric Y-axis values for this series.
         * @param minY Minimum Y-value for this series' scaling.
         * @param maxY Maximum Y-value for this series' scaling.
         * @param seriesColor Color for the line of this series.
         */
        function drawSingleSeriesGraph(canvas, seriesName, xValues, yValues, minY, maxY, seriesColor) {
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1; // Device pixel ratio for sharper graphics
            canvas.width = INTRINSIC_CANVAS_WIDTH * dpr; // Set internal resolution for high-DPI screens
            canvas.height = INTRINSIC_CANVAS_HEIGHT * dpr;
            ctx.scale(dpr, dpr); // Scale context to match device pixel ratio

            ctx.clearRect(0, 0, INTRINSIC_CANVAS_WIDTH, INTRINSIC_CANVAS_HEIGHT); // Clear drawing area
            ctx.fillStyle = 'black'; // Explicitly set canvas background to black
            ctx.fillRect(0, 0, INTRINSIC_CANVAS_WIDTH, INTRINSIC_CANVAS_HEIGHT);

            const graphWidth = INTRINSIC_CANVAS_WIDTH - 2 * PADDING;
            const graphHeight = INTRINSIC_CANVAS_HEIGHT - 2 * PADDING;

            // Scaling factors to map data to canvas coordinates
            const scaleX = (globalMaxX - globalMinX === 0) ? 1 : graphWidth / (globalMaxX - globalMinX);
            const scaleY = (maxY - minY === 0) ? 1 : graphHeight / (maxY - minY);

            // Draw horizontal grid lines
            ctx.strokeStyle = GRID_COLOR; // Faint red for grid
            ctx.lineWidth = 0.5;

            const numYGridLines = 4; // Adjust number of horizontal grid lines if needed
            for (let i = 0; i <= numYGridLines; i++) {
                const yPos = PADDING + i * (graphHeight / numYGridLines);
                ctx.beginPath();
                ctx.moveTo(PADDING, yPos);
                ctx.lineTo(PADDING + graphWidth, yPos);
                ctx.stroke();
            }

            // Draw vertical grid lines
            const numXGridLines = 7; // Number of vertical grid lines, adjust as needed
            for (let i = 0; i <= numXGridLines; i++) {
                const xPos = PADDING + i * (graphWidth / numXGridLines);
                ctx.beginPath();
                ctx.moveTo(xPos, PADDING);
                ctx.lineTo(xPos, PADDING + graphHeight);
                ctx.stroke();
            }

            // Draw data line
            ctx.beginPath();
            ctx.strokeStyle = seriesColor; // Use the passed seriesColor (red)
            ctx.lineWidth = 2;

            if (xValues.length > 0 && yValues.length > 0) {
                let firstPointDrawn = false;
                for (let i = 0; i < xValues.length; i++) {
                    const x = xValues[i];
                    const y = yValues[i];

                    if (!isNaN(x) && !isNaN(y)) {
                        // Map data coordinates to canvas pixel coordinates using global X-scale
                        const canvasX = PADDING + (x - globalMinX) * scaleX;
                        // Y-axis is inverted in canvas (0 is top, max is bottom)
                        const canvasY = PADDING + graphHeight - (y - minY) * scaleY;

                        if (!firstPointDrawn) {
                            ctx.moveTo(canvasX, canvasY);
                            firstPointDrawn = true;
                        } else {
                            ctx.lineTo(canvasX, canvasY);
                        }
                    }
                }
            }
            ctx.stroke(); // Finalize the line drawing

            // Draw axes and labels
            ctx.strokeStyle = AXIS_COLOR; // Darker gray for axis lines
            ctx.fillStyle = FONT_COLOR; // Light gray for text
            ctx.lineWidth = 1;
            ctx.font = '14px Inter, sans-serif'; // Slightly larger font for axis labels

            // Y-axis Label (positioned at top-left, horizontal)
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(seriesName, PADDING, PADDING - 15); // Adjusted Y position for title

            // Y-axis values (vertical, left of axis)
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            // Tick values for Y-axis (min and max)
            ctx.fillText(minY.toFixed(2), PADDING - 5, INTRINSIC_CANVAS_HEIGHT - PADDING - 5);
            ctx.fillText(maxY.toFixed(2), PADDING - 5, PADDING + 5);

            // Main Y-axis line (left)
            ctx.beginPath();
            ctx.moveTo(PADDING, PADDING);
            ctx.lineTo(PADDING, INTRINSIC_CANVAS_HEIGHT - PADDING);
            ctx.stroke();

            // Main X-axis line (bottom) - only for the last graph container to match the image style
            // This is handled by a separate DOM element now, so no need to draw here.
        }

        /**
         * @brief Handles mouse movement over a graph canvas to display the cursor and values.
         * This now also updates the global X-cursor.
         * @param e The mouse event.
         * @param canvas The HTMLCanvasElement being hovered over.
         * @param seriesData The data for the current graph series.
         * @param cursorElements Object containing references to local cursor DOM elements.
         */
        function handleMouseMove(e, canvas, seriesData, cursorElements) {
            // ALWAYS redraw the base graph at the start of mouseMove
            // This ensures previous highlights are cleared before drawing a new one or no highlight
            drawSingleSeriesGraph(
                canvas,
                seriesData.name,
                seriesData.xValues,
                seriesData.yValues,
                seriesData.minY, seriesData.maxY,
                DATA_LINE_COLOR
            );

            const rect = canvas.getBoundingClientRect(); // Get canvas's size and position in viewport
            const mouseXInCanvasCSS = e.clientX - rect.left; // Mouse X relative to canvas (CSS pixels)
            const mouseYInCanvasCSS = e.clientY - rect.top; // Mouse Y relative to canvas (CSS pixels)

            // Calculate effective padding and graph dimensions based on the actual rendered size
            const effectivePaddingX = PADDING * (rect.width / INTRINSIC_CANVAS_WIDTH);
            const effectivePaddingY = PADDING * (rect.height / INTRINSIC_CANVAS_HEIGHT);

            const graphRenderedWidth = rect.width - 2 * effectivePaddingX;
            const graphRenderedHeight = rect.height - 2 * effectivePaddingY;

            // Check if cursor is within graph *plotting area* (inside effective padding)
            if (mouseXInCanvasCSS >= effectivePaddingX && mouseXInCanvasCSS <= rect.width - effectivePaddingX &&
                mouseYInCanvasCSS >= effectivePaddingY && mouseYInCanvasCSS <= rect.height - effectivePaddingY) {

                // Convert mouseXInCanvasCSS (CSS pixel on rendered canvas) to data X-value
                const dataXAtMouse = globalMinX + (mouseXInCanvasCSS - effectivePaddingX) / (graphRenderedWidth / (globalMaxX - globalMinX));

                // Find the closest data point's index
                const closestIndex = findClosestDataPointIndex(seriesData.xValues, dataXAtMouse);

                if (closestIndex !== -1) {
                    const snappedDataX = seriesData.xValues[closestIndex];
                    const snappedDataY = seriesData.yValues[closestIndex];

                    // Convert snapped data points back to canvas CSS pixel coordinates (relative to canvas's top-left)
                    const scaleXGlobal = (globalMaxX - globalMinX === 0) ? 1 : graphRenderedWidth / (globalMaxX - globalMinX);
                    const scaleYLocal = (seriesData.maxY - seriesData.minY === 0) ? 1 : graphRenderedHeight / (seriesData.maxY - seriesData.minY);

                    const snappedCanvasXCSS = effectivePaddingX + (snappedDataX - globalMinX) * scaleXGlobal;
                    const snappedCanvasYCSS = effectivePaddingY + graphRenderedHeight - (snappedDataY - seriesData.minY) * scaleYLocal;

                    // --- Update Global Vertical Cursor and X-Label ---
                    const graphsContainerRect = graphsContainer.getBoundingClientRect();
                    const canvasOffsetInContainerX = rect.left - graphsContainerRect.left; // Canvas left relative to container
                    // The global vertical cursor's height now spans all graphs *up to* the common X-axis
                    // Its position is relative to the `graphs-container` which is `position:relative`
                    globalVerticalCursor.style.left = `${canvasOffsetInContainerX + snappedCanvasXCSS}px`;
                    globalVerticalCursor.style.top = `0px`; // Position at top of graphsContainer
                    globalVerticalCursor.style.height = `${graphsContainerRect.height - 60}px`; // Height of all graphs (minus common X-axis ruler height)
                    globalVerticalCursor.style.display = 'block';


                    globalXLabel.style.left = `${canvasOffsetInContainerX + snappedCanvasXCSS}px`;
                    globalXLabel.textContent = `${snappedDataX.toFixed(2)}`;
                    globalXLabel.style.display = 'block';

                    // --- Update Local Horizontal Cursor and Y-Label ---
                    cursorElements.horizontalLine.style.top = `${canvas.offsetTop + snappedCanvasYCSS}px`;
                    cursorElements.horizontalLine.style.left = `${canvas.offsetLeft + effectivePaddingX}px`;
                    cursorElements.horizontalLine.style.width = `${graphRenderedWidth}px`;
                    cursorElements.horizontalLine.style.display = 'block';

                    cursorElements.yLabel.style.top = `${canvas.offsetTop + snappedCanvasYCSS - 10}px`;
                    cursorElements.yLabel.style.left = `${canvas.offsetLeft + effectivePaddingX - 5}px`;
                    cursorElements.yLabel.textContent = `${snappedDataY.toFixed(2)}`;
                    cursorElements.yLabel.style.display = 'block';

                    // --- Draw Highlighted Point on Canvas ---
                    drawGraphHighlight(canvas, snappedCanvasXCSS, snappedCanvasYCSS, DATA_LINE_COLOR);

                } else {
                    hideLocalCursor(cursorElements);
                    // No need to redraw here, already redrawn at the start of func
                }
            } else {
                hideLocalCursor(cursorElements);
                hideGlobalXCursor(); // This one now only hides when mouse *leaves the whole container*
            }
        }

        /**
         * @brief Draws a highlighted circle on the canvas at the snapped data point.
         * @param canvas The canvas to draw on.
         * @param x The canvas X-coordinate (CSS pixels) of the point.
         * @param y The canvas Y-coordinate (CSS pixels) of the point.
         * @param color The color of the circle.
         */
        function drawGraphHighlight(canvas, x, y, color) {
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            ctx.save();
            ctx.scale(dpr, dpr); // Scale context

            ctx.beginPath();
            ctx.arc(x, y, 6, 0, Math.PI * 2); // Larger circle for highlight
            ctx.fillStyle = color; // Fill with series color
            ctx.fill();
            ctx.strokeStyle = 'white'; // White border for contrast
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.restore();
        }

        /**
         * @brief Hides the local cursor lines and labels for a specific graph.
         * @param cursorElements Object containing references to cursor DOM elements.
         */
        function hideLocalCursor(cursorElements) {
            cursorElements.horizontalLine.style.display = 'none';
            cursorElements.yLabel.style.display = 'none';
        }

        /**
         * @brief Hides the global X-axis cursor and its label.
         */
        function hideGlobalXCursor() {
            globalVerticalCursor.style.display = 'none';
            globalXLabel.style.display = 'none';

            // Redraw all graphs to clear any lingering highlights
            allSeriesData.forEach(series => {
                const canvas = document.getElementById(series.canvasId);
                if (canvas) {
                     drawSingleSeriesGraph(
                        canvas,
                        series.name,
                        series.xValues,
                        series.yValues,
                        series.minY, series.maxY,
                        DATA_LINE_COLOR
                    );
                }
            });
        }

        /**
         * @brief Renders all processed data series as individual graphs.
         * @param processedSeriesData Array of series data objects.
         */
        function renderGraphs(processedSeriesData) {
            graphsContainer.innerHTML = ''; // Clear previous graphs and initial message
            hideError(); // Clear any existing error messages
            initialMessageElement.classList.add('hidden'); // Hide initial message

            if (processedSeriesData.length === 0) {
                graphsContainer.appendChild(initialMessageElement); // Re-add initial message
                initialMessageElement.classList.remove('hidden');
                displayError('No valid numeric data series found for graphing. Please check your CSV columns.');
                return;
            }

            // Append global cursor elements back to the container
            graphsContainer.appendChild(globalVerticalCursor);
            graphsContainer.appendChild(globalXLabel);


            processedSeriesData.forEach((series, index) => {
                // Create container div for each graph
                const graphDiv = document.createElement('div');
                graphDiv.className = 'bg-black w-full max-w-4xl relative overflow-hidden';
                // Add top border, but not for the first graph
                if (index > 0) {
                     graphDiv.style.borderTop = '1px solid #4b5563';
                }


                // Canvas element for drawing the graph
                const canvas = document.createElement('canvas');
                canvas.id = series.canvasId; // Assign an ID for easy lookup
                canvas.className = 'cursor-crosshair';
                canvas.style.maxWidth = `${INTRINSIC_CANVAS_WIDTH}px`; // Maintain aspect ratio via CSS width/height:auto

                // --- Create Local Cursor Elements (initially hidden) ---
                const horizontalLine = document.createElement('div');
                horizontalLine.className = 'absolute bg-red-500 pointer-events-none hidden';
                horizontalLine.style.height = '1px';

                const yLabel = document.createElement('div');
                yLabel.className = 'absolute bg-gray-900 text-red-500 text-xs px-2 py-1 rounded shadow-md pointer-events-none whitespace-nowrap hidden';
                yLabel.style.transform = 'translateX(-100%)';
                yLabel.style.minWidth = '50px';
                yLabel.style.textAlign = 'right';
                yLabel.style.zIndex = '10';

                // Store references to local cursor elements
                const cursorElements = {
                    horizontalLine,
                    yLabel
                };

                // Append elements to the graph container (order matters for z-index/overlay)
                graphDiv.appendChild(canvas); // Canvas first so cursor elements can overlay
                graphDiv.appendChild(horizontalLine);
                graphDiv.appendChild(yLabel);

                graphsContainer.appendChild(graphDiv);

                // Draw the graph on the canvas
                drawSingleSeriesGraph(
                    canvas,
                    series.name,
                    series.xValues,
                    series.yValues,
                    series.minY, series.maxY,
                    DATA_LINE_COLOR
                );

                // Add event listeners for cursor interaction to each canvas
                canvas.addEventListener('mousemove', (e) => handleMouseMove(e, canvas, series, cursorElements));
                canvas.addEventListener('mouseleave', (e) => {
                    const relatedTarget = e.relatedTarget;
                    const isLeavingContainer = !graphsContainer.contains(relatedTarget);

                    if (isLeavingContainer) {
                        hideGlobalXCursor(); // Hide global cursor only if leaving container
                    }
                    hideLocalCursor(cursorElements); // Always hide local cursor on mouseleave from individual canvas
                    // Redraw specific graph to clear highlight
                    drawSingleSeriesGraph(
                        canvas,
                        series.name,
                        series.xValues,
                        series.yValues,
                        series.minY, series.maxY,
                        DATA_LINE_COLOR
                    );
                });
            });

            // After all graphs are rendered, add the common X-axis ruler at the bottom
            const commonXAxisRuler = document.createElement('div');
            commonXAxisRuler.id = 'global-x-axis-ruler';

            // Calculate tick values and append spans for them
            const numTicks = 6; // To get 7 labels (0-6 like 200, 300..700 in image)
            const tickStep = (globalMaxX - globalMinX) / numTicks;

            for (let i = 0; i <= numTicks; i++) {
                const tickValue = globalMinX + (tickStep * i);
                const span = document.createElement('span');
                span.textContent = tickValue.toFixed(0); // Display as integers
                span.style.position = 'absolute';
                // Calculate position based on graph width and padding
                const graphWidthAvailable = INTRINSIC_CANVAS_WIDTH - 2 * PADDING;
                const percentPosition = (tickValue - globalMinX) / (globalMaxX - globalMinX);
                const leftPosition = PADDING + (percentPosition * graphWidthAvailable);
                span.style.left = `${leftPosition}px`;
                span.style.transform = 'translateX(-50%)'; // Center text on the position
                commonXAxisRuler.appendChild(span);
            }

            // Add the X-axis label itself, centered.
            const xAxisLabelSpan = document.createElement('span');
            xAxisLabelSpan.textContent = globalXAxisLabel || 'Time'; // Use actual X-axis label or 'Time'
            xAxisLabelSpan.style.position = 'absolute';
            xAxisLabelSpan.style.bottom = '5px'; // Position below the numbers
            xAxisLabelSpan.style.left = '50%';
            xAxisLabelSpan.style.transform = 'translateX(-50%)';
            xAxisLabelSpan.style.fontSize = '14px';
            commonXAxisRuler.appendChild(xAxisLabelSpan);


            graphsContainer.appendChild(commonXAxisRuler);

            // Compute actual padding for the ruler based on max-width and internal padding
            const rulerRect = commonXAxisRuler.getBoundingClientRect();
            const rulerPaddingLeft = (rulerRect.width - (INTRINSIC_CANVAS_WIDTH - 2 * PADDING)) / 2 + PADDING; // Assuming centering
            commonXAxisRuler.style.setProperty('--padding-left-computed', `${rulerPaddingLeft}px`);
            commonXAxisRuler.style.setProperty('--padding-right-computed', `${rulerPaddingLeft}px`);


            // Set the overall height of the global vertical cursor after all graphs are rendered
            const totalGraphsHeight = graphsContainer.offsetHeight - commonXAxisRuler.offsetHeight;
            globalVerticalCursor.style.height = `${totalGraphsHeight}px`;
            globalVerticalCursor.style.top = `0px`; // Relative to graphsContainer top
            globalXLabel.style.bottom = `${commonXAxisRuler.offsetHeight + 5}px`; // Position above the ruler's bottom edge

            // Dynamically adjust padding-left and padding-right for the ruler
            // This is complex due to `max-width` and centering of `graphs-container`
            // Let's get the actual rendered width of the first canvas to compute the effective padding
            const firstCanvas = graphsContainer.querySelector('canvas');
            if (firstCanvas) {
                const firstCanvasRect = firstCanvas.getBoundingClientRect();
                const effectiveGraphRenderedWidth = firstCanvasRect.width - 2 * (PADDING * (firstCanvasRect.width / INTRINSIC_CANVAS_WIDTH));
                const spaceOutsideGraph = (rulerRect.width - effectiveGraphRenderedWidth) / 2;

                commonXAxisRuler.style.paddingLeft = `${spaceOutsideGraph}px`;
                commonXAxisRuler.style.paddingRight = `${spaceOutsideGraph}px`;
            }

        }

        // --- Event Listener for File Input ---
        csvUploadInput.addEventListener('change', (event) => {
            hideError(); // Clear previous errors
            const file = event.target.files[0];
            if (file) {
                if (!file.name.endsWith('.csv')) {
                    displayError('Please select a .csv file.');
                    graphsContainer.innerHTML = '';
                    graphsContainer.appendChild(initialMessageElement);
                    initialMessageElement.classList.remove('hidden');
                    return;
                }

                const reader = new FileReader();

                reader.onload = (e) => {
                    const text = e.target.result;
                    try {
                        const parsedData = parseCSV(text);
                        if (parsedData.length <= 1 || parsedData[0].length < 2) {
                            displayError('CSV must contain at least a header row and two columns (X-axis and one Y-axis series).');
                            graphsContainer.innerHTML = '';
                            graphsContainer.appendChild(initialMessageElement);
                            initialMessageElement.classList.remove('hidden');
                            return;
                        }

                        const headers = parsedData[0];
                        const rawDataRows = parsedData.slice(1);

                        // Store global X-axis label
                        globalXAxisLabel = headers[0] || '';

                        // Extract X-axis values from the first column of all data rows
                        const allXValues = rawDataRows.map(row => parseFloat(row[0])).filter(val => !isNaN(val));

                        if (allXValues.length === 0) {
                            displayError(`No valid numeric data found for X-axis (column "${headers[0]}").`);
                            graphsContainer.innerHTML = '';
                            graphsContainer.appendChild(initialMessageElement);
                            initialMessageElement.classList.remove('hidden');
                            return;
                        }

                        globalMinX = Math.min(...allXValues);
                        globalMaxX = Math.max(...allXValues);

                        // Process data for each series
                        allSeriesData = []; // Reset global series data
                        for (let colIndex = 1; colIndex < headers.length; colIndex++) {
                            const yValues = rawDataRows.map(row => parseFloat(row[colIndex])).filter(val => !isNaN(val));

                            if (yValues.length > 0) {
                                const minY = Math.min(...yValues);
                                const maxY = Math.max(...yValues);
                                allSeriesData.push({
                                    id: `series-${colIndex}`,
                                    canvasId: `canvas-series-${colIndex}`, // Unique ID for each canvas
                                    name: headers[colIndex],
                                    xValues: allXValues, // Use the globally extracted X values
                                    yValues,
                                    minY,
                                    maxY,
                                    color: DATA_LINE_COLOR, // Fixed red color
                                    xAxisLabel: headers[0] // Stored for potential use, but X-axis label is now global
                                });
                            }
                        }

                        renderGraphs(allSeriesData); // Render all graphs
                    } catch (err) {
                        displayError('Error parsing CSV file: ' + err.message);
                        graphsContainer.innerHTML = '';
                        graphsContainer.appendChild(initialMessageElement);
                        initialMessageElement.classList.remove('hidden');
                    }
                };

                reader.onerror = () => {
                    displayError('Failed to read file.');
                    graphsContainer.innerHTML = '';
                    graphsContainer.appendChild(initialMessageElement);
                    initialMessageElement.classList.remove('hidden');
                };

                reader.readAsText(file); // Read the file content as text
            } else {
                graphsContainer.innerHTML = '';
                graphsContainer.appendChild(initialMessageElement);
                initialMessageElement.classList.remove('hidden');
            }
        });
    </script>
</body>
</html>
